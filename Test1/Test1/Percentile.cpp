#include "Percentile.h"

using namespace std;


int compare(const void * x1, const void * x2)   // функция сравнения элементов массива
{
	return (*(int*)x1 - *(int*)x2);              // если результат вычитания равен 0, то числа равны, < 0: x1 < x2; > 0: x1 > x2
}

double Percentile(double percNum, vector<int> &myVector) {

	if (percNum < 0 || percNum>100) {
		cout << "Percentiles value is out of boundary\n";
		exit(0);
	}

	qsort(&myVector[0], myVector.size(), sizeof(int), compare);

	//Рассмотрим упорядоченный массив как отрезок прямой условной длинны 1 единица, элементы этого массива будут равноудаленными 
	//друг от друга точками на этой прямой, где крайняя левая точка - это первый элемент, а крайняя правая - последний.
	//Таким образом если например наш упорядоченный массив массив значений будет таким {-2, 7, 11, 11} - то воображаемый отрезок 
	//условной длинны 1 будет отрезком [-2;14] координатной оси , но при этом значения но при всем при этом расстояние между точками -2 и 7 
	//будет равным расстоянию между точками 7 и 11, а обе точки 11 и 11 можно представить как 2 отрезка, каждый из которых равный по длинне 
	//этому же расстоянию. Таким образом все точки нашего набора являются равновероятными.

	//Разобъем наш отсортированный массив на равновероятные интервалы в которых будет находиться искомый персентиль

	if (myVector.size() == 1) {
		return myVector[0];//в случае если в массиве число элементов равно 1, тогда этот элемент и будет являться любым персентилем
	}


	double 	interval = 1.0 / (myVector.size() - 1); //если же в массиве число элементов больше 1, вероятностное пространство равное 1 
													//разбивается на n-1 равновероятных отрезка, где n - число элементов массива
	int leftBoundInd = static_cast<int>((percNum / 100.0) / interval);//находим индекс левой гранцы интервала в котором будем искать персентиль, деля 
																	  //передаваемый  в данную ф-цию номер персентиля на 100 (таким образом мы делаем 
																	  //из номера персентиля часть отрезка вероятностного пространства равного 1) и на
																	  // значение вышеупомянутого интервала и берем целую часть.

	int rightBoundInd;
	if (leftBoundInd == myVector.size() - 1)//если левая граница интервала - это последня точка массива
		rightBoundInd = leftBoundInd;			//индекс правой границы будет равен индесу левой
	else							   //в противном же случае
		rightBoundInd = leftBoundInd + 1;   //индекс правой границы будет равен индесу левой+1



	double percentile = ((((percNum / 100.0) - interval*leftBoundInd) / interval))*(myVector[rightBoundInd] - myVector[leftBoundInd]) + myVector[leftBoundInd];
	//от персентиля выраженного в части отрезка вероятностного пространства равнго 1 (percNum / 100.0) отнимем значение интервала умноженного на индекс 
	//левой границы интервала interval*leftBoundInd в котором мы ищем искомый персентиль - так находим остаток от искомой части персентиля который
	//далее делится на значение интервала для масштабирования, затем это значение необходимо необходимо умножить на разность
	// между значением по индексу правой границы интервала от значения по индексу от левой границы интервала, таким образом мы 
	//получаем часть отрезка интервала, на котором и находится искмое значение. Остается к этому значению прибавить значение по индексу от левой 
	//границы интервала.

	return percentile;
}